{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../../node_modules/moo/moo.js","../../../src/create-token.js","../../../src/token-utils.js","../../../src/strategies/fetch.js","../../../src/strategies/first.js","../../../src/strategies/limit.js","../../../src/strategies/top.js","../../../src/strategies/index.js","../../../src/statement.js","../../../src/get-statements.js","../../../src/keywords.js","../../../src/index.js","../../node_modules/text-diff/diff.js","../../src/SqlDiff.svelte","../../src/Strategies.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.35.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","module.exports = {\n  singleSpace() {\n    return {\n      type: \"whitespace\",\n      text: \" \",\n      value: \" \",\n    };\n  },\n  keyword(text) {\n    return {\n      type: \"keyword\",\n      text,\n      value: text.toLowerCase(),\n    };\n  },\n  number(n) {\n    return {\n      type: \"number\",\n      text: `${n}`,\n      value: n,\n    };\n  },\n};\n","function findParenLevelToken(tokens, startingIndex, predicate) {\n  let level = 0;\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (!token) {\n      return null;\n    }\n    if (token.type === \"lparen\") {\n      level++;\n    } else if (token.type === \"rparen\") {\n      level--;\n    } else if (level === 0 && predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction findToken(tokens, startingIndex, predicate) {\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction nextNonCommentNonWhitespace(tokens, startingIndex) {\n  return findToken(\n    tokens,\n    startingIndex,\n    (token) => token.type !== \"whitespace\" && token.type !== \"comment\"\n  );\n}\n\nfunction findLimitInsertionIndex(queryTokens, targetParenLevel) {\n  let level = 0;\n  for (let i = queryTokens.length - 1; i >= 0; i--) {\n    const token = queryTokens[i];\n    if (\n      level === targetParenLevel &&\n      token.type !== \"comment\" &&\n      token.type !== \"whitespace\"\n    ) {\n      return i + 1;\n    }\n\n    if (token.type === \"rparen\") {\n      level++;\n    } else if (token.type === \"lparen\") {\n      level--;\n    }\n  }\n  // This should never happen.\n  // And if it did this lib doesn't know what to do\n  throw new Error(\"Unexpected index\");\n}\n\nmodule.exports = {\n  findParenLevelToken,\n  findToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Determines whether query tokens have \"FETCH\" style limits\n * Postgres, IBM, Actian/Ingres, SQL Server 2012 support this SQL 2008 addition\n *\n * The postgres docs showcase the format nicely:\n * [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n * [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n *\n * For the purposes of sql-limiter, we will look for \"fetch first <number>\" and \"fetch next <number>\"\n * Assuming that whitespace or comments can be between\n *\n * Resources:\n * https://www.postgresql.org/docs/12/sql-select.html\n * https://docs.actian.com/ingres/10s/index.html#page/SQLRef%2FSELECT_Clause.htm%23\n * https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/sqlref/src/tpc/db2z_sql_fetchfirstclause.html\n * https://use-the-index-luke.com/sql/partial-results/top-n-queries\n *\n * @param {array<object>} tokens\n * @param {number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const fetchKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"fetch\"\n  );\n\n  if (!fetchKeywordToken) {\n    return null;\n  }\n\n  let nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    fetchKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (\n    nextNonWC.type !== \"keyword\" ||\n    (nextNonWC.value !== \"next\" && nextNonWC.value !== \"first\")\n  ) {\n    throw new Error(`Unexpected token: ${nextNonWC.type} ${nextNonWC.value}`);\n  }\n\n  nextNonWC = nextNonCommentNonWhitespace(tokens, nextNonWC.index + 1);\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // fetch first was not found, so figure out where it should be inserted\n  // fetch first goes at end before for if that exists. Otherwise before terminator if it exists\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"keyword\" && token.value === \"for\"\n  );\n\n  const fetchToOnlyTokens = [\n    createToken.keyword(\"fetch\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    createToken.singleSpace(),\n    createToken.keyword(\"rows\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"only\"),\n  ];\n\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      ...fetchToOnlyTokens,\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      ...fetchToOnlyTokens,\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    ...fetchToOnlyTokens,\n    ...secondhalf,\n  ];\n}\n\nmodule.exports = {\n  has,\n  add,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the FIRST keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const firstKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"first\"\n  );\n\n  if (!firstKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    firstKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds FIRST to query that does not have it.\n *\n * FIRST is an Actian keyword that operates similar to SQL Server's TOP.\n * TODO - find documentation/examples to figure out if there are any potential edge cases with this solution\n * https://docs.actian.com/vectorhadoop/6.0/#page/SQLLang%2FSELECT_(Interactive).htm%23\n *\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // FIRST was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\nfunction has(tokens, startingIndex) {\n  const limitKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"limit\"\n  );\n\n  if (!limitKeywordToken) {\n    return null;\n  }\n\n  // Supported LIMIT syntaxes\n  // LIMIT <limit_number>                   (most common)\n  // LIMIT <offset_number>,<limit_number>   (supported by ClickHouse)\n\n  const firstNumber = nextNonCommentNonWhitespace(\n    tokens,\n    limitKeywordToken.index + 1\n  );\n\n  if (!firstNumber) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (firstNumber.type !== \"number\") {\n    throw new Error(`Expected number got ${firstNumber.type}`);\n  }\n\n  // Check to see if next non whitespace past first number is a comma\n  // If it is, and that is followed by another number\n  // We are likely dealing with a ClickHouse LIMIT <offset_number>,<limit_number> syntax\n  const possibleComma = nextNonCommentNonWhitespace(\n    tokens,\n    firstNumber.index + 1\n  );\n\n  // If next token doesn't exist, or is not a comma\n  // return the first number as it is the limit\n  if (!possibleComma) {\n    return firstNumber;\n  }\n\n  if (possibleComma.type !== \"comma\") {\n    return firstNumber;\n  }\n\n  // Since we are dealing with \"LIMIT <number> <comma>\" find next number,\n  // as it will be the actual limit for ClickHouse syntax\n  const secondNumber = nextNonCommentNonWhitespace(\n    tokens,\n    possibleComma.index + 1\n  );\n\n  if (!secondNumber) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (secondNumber.type !== \"number\") {\n    throw new Error(`Expected number got ${secondNumber.type}`);\n  }\n\n  return secondNumber;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // Limit was not found, so figure out where it should be inserted\n  // If last keyword is offset, need to put limit before that\n  // If not offset, put limit at end, before terminator if present\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) =>\n      token.type === \"keyword\" &&\n      (token.value === \"offset\" || token.value === \"for\")\n  );\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"limit\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the TOP keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const topKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"top\"\n  );\n\n  if (!topKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    topKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds TOP to query that does not have it.\n *\n * TOP in Actian behaves similar to its FIRST keyword, and SQL Server's TOP (though unclear about its compat with UNION)\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // TOP was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"top\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const fetch = require(\"./fetch\");\nconst first = require(\"./first\");\nconst limit = require(\"./limit\");\nconst top = require(\"./top\");\n\nmodule.exports = {\n  fetch,\n  first,\n  limit,\n  top,\n};\n","/* eslint-disable no-restricted-syntax */\nconst strategies = require(\"./strategies\");\n\nclass Statement {\n  constructor() {\n    this.tokens = [];\n    this.parenLevel = 0;\n    this.targetParenLevel = null;\n    this.statementToken = null;\n    this.fetchToken = null;\n    this.limitToken = null;\n  }\n\n  appendToken(t) {\n    const token = { ...t };\n    token.parenLevel = this.parenLevel;\n    // Index once token is added\n    token.index = this.tokens.length;\n    this.tokens.push(token);\n\n    if (token.type === \"lparen\") {\n      this.parenLevel++;\n    } else if (token.type === \"rparen\") {\n      this.parenLevel--;\n    } else if (token.type === \"keyword\") {\n      // If targetParenLevel has not yet been set,\n      // we are dealing with the first keyword, which informs us of the \"level\"\n      // we want to consider for finding SELECT statments\n      if (this.targetParenLevel === null) {\n        this.targetParenLevel = this.parenLevel;\n      }\n      // Statement keyword we are considering not something found in prep of CTE\n      // If the current keyword isn't a `with` and not `as`, and at the same level as our targetParenLevel,\n      // We can assume it tells us what kind of query we are dealing with.\n      // Consider queries like the following queries\n      //\n      // WITH cte AS (...) SELECT ...\n      // WITH cte AS (...) INSERT INTO ... SELECT\n      // WITH cte AS (...) UPDATE ... FROM ...\n      // (WITH cte AS (...) SELECT ...)\n      if (\n        !this.statementToken &&\n        this.targetParenLevel === this.parenLevel &&\n        token.value !== \"with\" &&\n        token.value !== \"as\"\n      ) {\n        this.statementToken = token;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Array<String>} strategiesToEnforce\n   * @param {Number} limitNumber\n   */\n  enforceLimit(strategiesToEnforce, limitNumber) {\n    const { statementToken, tokens } = this;\n\n    strategiesToEnforce.forEach((s) => {\n      if (!strategies[s]) {\n        throw new Error(`Strategy ${s} not supported`);\n      }\n    });\n\n    if (statementToken && statementToken.value === \"select\") {\n      for (const toEnforce of strategiesToEnforce) {\n        const strategyImplementation = strategies[toEnforce];\n        const numberToken = strategyImplementation.has(\n          tokens,\n          statementToken.index\n        );\n\n        // If number token, check to see if over the limit and reset it if it is\n        // Otherwise return early\n        if (numberToken) {\n          if (parseInt(numberToken.value, 10) > limitNumber) {\n            const firstHalf = tokens.slice(0, numberToken.index);\n            const secondhalf = tokens.slice(numberToken.index + 1);\n            this.tokens = [\n              ...firstHalf,\n              { ...numberToken, text: limitNumber, value: limitNumber },\n              ...secondhalf,\n            ];\n            return;\n          }\n          return;\n        }\n      }\n\n      // An existing limit strategy was not found,\n      // so take the first one in list of strategies to enforce and add it to tokens\n      const preferredStrategy = strategiesToEnforce[0];\n      this.tokens = strategies[preferredStrategy].add(\n        tokens,\n        statementToken.index,\n        statementToken.parenLevel,\n        limitNumber\n      );\n    }\n  }\n\n  toString(stripTerminator = false) {\n    if (stripTerminator) {\n      return this.tokens\n        .filter((t) => t.type !== \"terminator\")\n        .map((t) => t.text)\n        .join(\"\");\n    }\n    return this.tokens.map((token) => token.text).join(\"\");\n  }\n}\n\nmodule.exports = Statement;\n","const moo = require(\"moo\");\nconst keywords = require(\"./keywords.js\");\nconst Statement = require(\"./statement\");\n\n// Incoming values will also be compared as lower case to make keyword matching case insensitive\nconst caseInsensitiveKeywords = (defs) => {\n  const defineKeywords = moo.keywords(defs);\n  return (value) => defineKeywords(value.toLowerCase());\n};\n\nconst lexer = moo.compile({\n  whitespace: [\n    /[ \\t]+/u,\n    { match: /\\r\\n/u, lineBreaks: true },\n    { match: /\\n/u, lineBreaks: true },\n  ],\n  // First expression is --line comment, second is /* multi line */\n  comment: [/--.*?$/u, /\\/\\*[^]*?\\*\\//u],\n  lparen: \"(\",\n  rparen: \")\",\n  comma: \",\",\n  period: \".\",\n\n  number: /0|[1-9][0-9]*/u,\n\n  // ; is standard, \\g is a shortcut used in psql and Actian tooling\n  // Are there others?\n  terminator: [\";\", \"\\\\g\"],\n\n  // text == original text\n  // value == value inside quotes\n  quotedIdentifier: [\n    {\n      match: /\".*?\"/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /\\[.*?\\]/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /`.*?`/u,\n      value: (x) => x.slice(1, -1),\n    },\n  ],\n\n  // Updated to allow multi-line strings,\n  // which is allowed by some database drivers (sqlite, actian)\n  // This does not correctly handle escaped doublequotes, however the end result is ok for sql-limiter\n  // Instead of a single string token we get 2 separate string tokens back-to-back\n  string: [\n    {\n      match: /'[^']*'/u,\n      lineBreaks: true,\n    },\n  ],\n\n  // Remaining test is assumed to be an identifier of some kinds (column or table)\n  // UNLESS it matches a keyword case insensitively\n  // The value of these tokens are converted to lower case\n  identifier: [\n    {\n      // This is added to handle non-english identifiers.\n      // This range may be too broad\n      // eslint-disable-next-line no-control-regex\n      match: /(?:\\w|[^\\u0000-\\u007F])+/u,\n      type: caseInsensitiveKeywords({\n        keyword: keywords,\n      }),\n      value: (s) => s.toLowerCase(),\n    },\n  ],\n\n  // Any combination of special characters is to be treated as an operator (as a guess anyways)\n  // Initially these were being noted here but the list is large\n  // and there is no way to know all operators since this supports anything that is SQL-ish\n  operator: {\n    match: /[<>~!@#$%^?&|`*\\-{}+=:/\\\\[\\]]+/u,\n    lineBreaks: false,\n  },\n});\n\n/**\n * Takes SQL text and generates an array of tokens using moo\n * @param {string} sqlText\n */\nfunction getStatements(sqlText) {\n  const statements = [];\n  let statement = new Statement();\n\n  lexer.reset(sqlText);\n  let next = lexer.next();\n\n  while (next) {\n    statement.appendToken(next);\n    if (next.type === \"terminator\") {\n      statements.push(statement);\n      statement = new Statement();\n    }\n    next = lexer.next();\n  }\n  // push last set\n  if (statement.tokens.length) {\n    statements.push(statement);\n  }\n  return statements;\n}\n\nmodule.exports = getStatements;\n","module.exports = [\n  \"absolute\",\n  \"action\",\n  \"ada\",\n  \"add\",\n  \"all\",\n  \"allocate\",\n  \"alter\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"as\",\n  \"asc\",\n  \"assertion\",\n  \"at\",\n  \"authorization\",\n  \"avg\",\n  \"backup\",\n  \"begin\",\n  \"between\",\n  \"bit_length\",\n  \"bit\",\n  \"both\",\n  \"break\",\n  \"browse\",\n  \"bulk\",\n  \"by\",\n  \"cascade\",\n  \"cascaded\",\n  \"case\",\n  \"cast\",\n  \"catalog\",\n  \"char_length\",\n  \"char\",\n  \"character_length\",\n  \"character\",\n  \"check\",\n  \"checkpoint\",\n  \"close\",\n  \"clustered\",\n  \"coalesce\",\n  \"collate\",\n  \"collation\",\n  \"column\",\n  \"commit\",\n  \"compute\",\n  \"connect\",\n  \"connection\",\n  \"constraint\",\n  \"constraints\",\n  \"contains\",\n  \"containstable\",\n  \"continue\",\n  \"convert\",\n  \"corresponding\",\n  \"count\",\n  \"create\",\n  \"cross\",\n  \"current_date\",\n  \"current_time\",\n  \"current_timestamp\",\n  \"current_user\",\n  \"current\",\n  \"cursor\",\n  \"database\",\n  \"date\",\n  \"day\",\n  \"dbcc\",\n  \"deallocate\",\n  \"dec\",\n  \"decimal\",\n  \"declare\",\n  \"default\",\n  \"deferrable\",\n  \"deferred\",\n  \"delete\",\n  \"deny\",\n  \"desc\",\n  \"describe\",\n  \"descriptor\",\n  \"diagnostics\",\n  \"disconnect\",\n  \"disk\",\n  \"distinct\",\n  \"distributed\",\n  \"domain\",\n  \"double\",\n  \"drop\",\n  \"dump\",\n  \"else\",\n  \"end-exec\",\n  \"end\",\n  \"errlvl\",\n  \"escape\",\n  \"except\",\n  \"exception\",\n  \"exec\",\n  \"execute\",\n  \"exists\",\n  \"exit\",\n  \"external\",\n  \"extract\",\n  \"false\",\n  \"fetch\",\n  \"file\",\n  \"fillfactor\",\n  \"first\",\n  \"float\",\n  \"for\",\n  \"foreign\",\n  \"fortran\",\n  \"found\",\n  \"freetext\",\n  \"freetexttable\",\n  \"from\",\n  \"full\",\n  \"function\",\n  \"get\",\n  \"global\",\n  \"go\",\n  \"goto\",\n  \"grant\",\n  \"group\",\n  \"having\",\n  \"holdlock\",\n  \"hour\",\n  \"identity_insert\",\n  \"identity\",\n  \"identitycol\",\n  \"if\",\n  \"immediate\",\n  \"in\",\n  \"include\",\n  \"index\",\n  \"indicator\",\n  \"initially\",\n  \"inner\",\n  \"input\",\n  \"insensitive\",\n  \"insert\",\n  \"int\",\n  \"integer\",\n  \"intersect\",\n  \"interval\",\n  \"into\",\n  \"is\",\n  \"isolation\",\n  \"join\",\n  \"key\",\n  \"kill\",\n  \"language\",\n  \"last\",\n  \"leading\",\n  \"left\",\n  \"level\",\n  \"like\",\n  \"limit\",\n  \"lineno\",\n  \"load\",\n  \"local\",\n  \"locked\",\n  \"lower\",\n  \"match\",\n  \"max\",\n  \"merge\",\n  \"min\",\n  \"minute\",\n  \"module\",\n  \"month\",\n  \"names\",\n  \"national\",\n  \"natural\",\n  \"nchar\",\n  \"next\",\n  \"no\",\n  \"nocheck\",\n  \"nonclustered\",\n  \"none\",\n  \"not\",\n  \"nowait\",\n  \"null\",\n  \"nullif\",\n  \"numeric\",\n  \"octet_length\",\n  \"of\",\n  \"off\",\n  \"offset\",\n  \"offsets\",\n  \"on\",\n  \"only\",\n  \"open\",\n  \"opendatasource\",\n  \"openquery\",\n  \"openrowset\",\n  \"openxml\",\n  \"option\",\n  \"or\",\n  \"order\",\n  \"outer\",\n  \"output\",\n  \"over\",\n  \"overlaps\",\n  \"pad\",\n  \"partial\",\n  \"pascal\",\n  \"percent\",\n  \"pivot\",\n  \"plan\",\n  \"position\",\n  \"precision\",\n  \"prepare\",\n  \"preserve\",\n  \"primary\",\n  \"print\",\n  \"prior\",\n  \"privileges\",\n  \"proc\",\n  \"procedure\",\n  \"public\",\n  \"raiserror\",\n  \"read\",\n  \"readtext\",\n  \"real\",\n  \"reconfigure\",\n  \"references\",\n  \"relative\",\n  \"replication\",\n  \"restore\",\n  \"restrict\",\n  \"return\",\n  \"revert\",\n  \"revoke\",\n  \"right\",\n  \"right\",\n  \"rollback\",\n  \"row\",\n  \"rowcount\",\n  \"rowguidcol\",\n  \"rows\",\n  \"rule\",\n  \"save\",\n  \"schema\",\n  \"scroll\",\n  \"second\",\n  \"section\",\n  \"securityaudit\",\n  \"select\",\n  \"semantickeyphrasetable\",\n  \"semanticsimilaritydetailstable\",\n  \"semanticsimilaritytable\",\n  \"session_user\",\n  \"session\",\n  \"set\",\n  \"setuser\",\n  \"share\",\n  \"shutdown\",\n  \"size\",\n  \"skip\",\n  \"smallint\",\n  \"some\",\n  \"space\",\n  \"sql\",\n  \"sqlca\",\n  \"sqlcode\",\n  \"sqlerror\",\n  \"sqlstate\",\n  \"sqlwarning\",\n  \"statistics\",\n  \"substring\",\n  \"sum\",\n  \"system_user\",\n  \"table\",\n  \"tablesample\",\n  \"temporary\",\n  \"textsize\",\n  \"then\",\n  \"time\",\n  \"timestamp\",\n  \"timezone_hour\",\n  \"timezone_minute\",\n  \"to\",\n  \"top\",\n  \"trailing\",\n  \"tran\",\n  \"transaction\",\n  \"translate\",\n  \"translation\",\n  \"trigger\",\n  \"trim\",\n  \"true\",\n  \"truncate\",\n  \"try_convert\",\n  \"tsequal\",\n  \"union\",\n  \"unique\",\n  \"unknown\",\n  \"unpivot\",\n  \"update\",\n  \"updatetext\",\n  \"upper\",\n  \"usage\",\n  \"use\",\n  \"user\",\n  \"using\",\n  \"value\",\n  \"values\",\n  \"varchar\",\n  \"varying\",\n  \"view\",\n  \"waitfor\",\n  \"when\",\n  \"whenever\",\n  \"where\",\n  \"while\",\n  \"with\",\n  \"within group\",\n  \"work\",\n  \"write\",\n  \"writetext\",\n  \"year\",\n  \"zone\",\n];\n","const getStatements = require(\"./get-statements\");\n\n/**\n * Enforce limit/top on SQL SELECT queries.\n * Non SELECT queries will not be altered.\n * If existing limit exists, it will be lowered if it is larger than `limitNumber` specified\n * If limit does not exist, it will be added.\n * Returns SQL text with limits enforced.\n *\n * @param {string} sqlText - sql text to limit\n * @param {Array<String>|String} limitStrategies -- First strategy value takes priority if no limit exists\n * @param {number} limitNumber -- number to enforce for limit keyword\n * @returns {string}\n */\nfunction limit(sqlText, limitStrategies, limitNumber) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  if (typeof limitNumber !== \"number\") {\n    throw new Error(\"limitNumber must be number\");\n  }\n\n  let strategies =\n    typeof limitStrategies === \"string\" ? [limitStrategies] : limitStrategies;\n\n  if (!Array.isArray(strategies)) {\n    throw new Error(\"limitStrategies must be an array or string\");\n  }\n\n  if (strategies.length === 0) {\n    throw new Error(\"limitStrategies must not be empty\");\n  }\n\n  strategies = strategies.map((s) => s.toLowerCase());\n\n  return getStatements(sqlText)\n    .map((statement) => {\n      statement.enforceLimit(strategies, limitNumber);\n      return statement.toString();\n    })\n    .join(\"\");\n}\n\n/**\n * Splits SQL text on terminator, returning an array of SQL statements\n * @param {string} sqlText\n */\nfunction apiGetStatements(sqlText) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlText);\n  return statements.map((statement) => statement.toString());\n}\n\n/**\n * Removes terminator from SQL statement.\n * Only a single statement allowed.\n * Throws error if multiple statements are included\n * @param {string} sqlStatement\n */\nfunction removeTerminator(sqlStatement) {\n  if (typeof sqlStatement !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlStatement)\n    .map((s) => s.toString(true))\n    .filter((s) => s.trim() !== \"\");\n\n  if (statements.length > 1) {\n    throw new Error(\"Multiple statements detected\");\n  }\n\n  return statements[0];\n}\n\nmodule.exports = {\n  limit,\n  getStatements: apiGetStatements,\n  removeTerminator,\n};\n","/**\n * This library was modified by Harrison Liddiard. The source code to this\n * modified version can be found at https://github.com/liddiard/google-diff/.\n * The original source code can be found at\n * http://code.google.com/p/google-diff-match-patch/. This unofficial fork is\n * not maintained by or affiliated with Google Inc. The original attribution\n * and licensing information follows.\n */\n\n/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff.\n * @constructor\n */\nfunction diff(options) {\n  var options = options || {};\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Timeout = options.timeout || 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.EditCost = options.editCost || 4;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n */\ndiff.prototype.main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.lineMode_(text1, text2, deadline);\n  }\n\n  return this.bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.main(text1a, text2a, false, deadline);\n  var diffsb = this.main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff.prototype.linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff.prototype.charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff.prototype.commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff.prototype.commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff.prototype.commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff.prototype.halfMatch_ = function(text1, text2) {\n  if (this.Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.commonPrefix(longtext.substring(i),\n                                          shorttext.substring(j));\n      var suffixLength = dmp.commonSuffix(longtext.substring(0, i),\n                                          shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n  this.cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff.whitespaceRegex_ = /\\s/;\ndiff.linebreakRegex_ = /[\\r\\n]/;\ndiff.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff.prototype.xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff.prototype.prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_br = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_br, '<br/>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins>' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del>' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff.prototype.text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff.prototype.text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff.prototype.levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff.prototype.toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff.prototype.fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// Users of node.js should 'require' the uncompressed version since Google's\n// JS compiler may break the following exports for non-browser environments.\nthis['diff'] = diff;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\nmodule.exports = diff;\n","<script>\n  import sqlLimiter from \"../../src/index.js\";\n  import Diff from \"text-diff\";\n\n  export let sql = \"\";\n  export let strategies = [\"limit\"];\n  export let limitNumber = 100;\n\n  let diff = new Diff();\n  let limited = \"\";\n  let textDiff;\n  let prettyHtml;\n  let error;\n\n  $: try {\n    error = null;\n    limited = sqlLimiter.limit(sql, strategies, limitNumber);\n    textDiff = diff.main(sql, limited);\n    prettyHtml = diff.prettyHtml(textDiff);\n  } catch (e) {\n    error = e;\n  }\n</script>\n\n{#if error}\n  <span class=\"error\">{error}</span>\n{:else}\n  {@html prettyHtml}\n{/if}\n\n<style>\n  :global(ins) {\n    color: green;\n  }\n\n  :global(del) {\n    color: red;\n  }\n\n  .error {\n    color: red;\n  }\n</style>\n","<script>\n  export let value = \"\";\n  export let label = \"strategy\";\n</script>\n\n<label for={label}>{label}</label>\n<select id={label} class=\"input\" bind:value>\n  <option value=\"\">\n    <em>none</em>\n  </option>\n  <option value=\"fetch\">fetch</option>\n  <option value=\"first\">first</option>\n  <option value=\"limit\">limit</option>\n  <option value=\"top\">top</option>\n</select>\n\n<style>\n  label {\n    font-variant: small-caps;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n</style>\n","<script>\n  import Logo from \"./Logo.svelte\";\n  import SqlDiff from \"./SqlDiff.svelte\";\n  import Strategies from \"./Strategies.svelte\";\n\n  let strategy1 = \"limit\";\n  let strategy2 = \"fetch\";\n  let strategy3 = \"\";\n  let limitNumber = 100;\n  let original = `SELECT * FROM some_table;`;\n\n  $: limitStrategies = [strategy1, strategy2, strategy3].filter(\n    (s) => s !== \"\"\n  );\n</script>\n\n<main>\n  <Logo />\n  <div class=\"row\">\n    <div class=\"col-100 m8\">\n      <h1>sql-limiter</h1>\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"m8\">\n      <Strategies label=\"strategy 1\" bind:value={strategy1} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 2\" bind:value={strategy2} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 3\" bind:value={strategy3} />\n    </div>\n    <div class=\"m8\">\n      <label for=\"limit-number\">limit number</label>\n      <input\n        id=\"limit-number\"\n        class=\"input\"\n        type=\"number\"\n        bind:value={limitNumber}\n      />\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"col-50 m8\">\n      <label for=\"sql-in\">input</label>\n      <textarea id=\"sql-in\" class=\"sql\" rows=\"15\" bind:value={original} />\n    </div>\n    <div class=\"col-50 m8\">\n      <span class=\"fake-label\">result</span>\n      <pre\n        class=\"sql out\">\n        <SqlDiff sql={original} strategies={limitStrategies} {limitNumber} />\n      </pre>\n    </div>\n  </div>\n</main>\n\n<style>\n  h1 {\n    color: #ff3e00;\n    font-variant: small-caps;\n    text-transform: uppercase;\n    font-size: 2em;\n    font-weight: 100;\n  }\n\n  label {\n    font-variant: small-caps;\n  }\n\n  .row {\n    display: flex;\n  }\n\n  .m8 {\n    margin: 8px;\n  }\n\n  .col-100 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n  .col-50 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n\n  #sql-in {\n    white-space: pre;\n  }\n\n  /* consistent styling for textarea and not */\n  .sql {\n    border-radius: 2px;\n    border: 1px solid #ccc;\n    box-sizing: border-box;\n    font-family: monospace;\n    font-size: 14px;\n    margin: 0;\n    padding: 8px;\n    width: 100%;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n\n  .out {\n    overflow-x: auto;\n  }\n\n  .fake-label {\n    font-variant: small-caps;\n  }\n</style>\n","import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","to_number","set_data","wholeText","set_input_value","input","select_option","select","i","length","option","__value","selected","HtmlTag","[object Object]","this","e","n","html","nodeName","t","h","innerHTML","Array","from","childNodes","d","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","add_flush_callback","flushing","seen_callbacks","Set","flush","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","transition_out","o","outros","c","bind","index","props","undefined","bound","create_component","mount_component","customElement","on_mount","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","parent_component","on_disconnect","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","children","l","intro","SvelteComponent","$destroy","type","indexOf","splice","$$props","obj","$$set","keys","root","factory","hasOwnProperty","prototype","toString","hasSticky","RegExp","sticky","isRegExp","call","isObject","isArray","reCapture","s","reUnion","regexps","join","regexpOrLiteral","replace","ignoreCase","Error","global","multiline","source","ruleOptions","match","include","defaultType","lineBreaks","error","fallback","next","shouldThrow","key","sort","toRules","spec","array","result","concat","j","JSON","stringify","arrayToRules","object","getOwnPropertyNames","rules","rule","objectToRules","defaultErrorRule","compileRules","hasStates","errorRule","fast","fastAllowed","unicodeFlag","groups","parts","slice","shift","charCodeAt","unicode","pat","regexp","test","exec","fallbackRule","flags","suffix","checkStateGroup","g","state","Lexer","states","startState","buffer","stack","reset","info","line","col","queuedToken","queuedThrow","setState","save","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","queuedGroup","token","_token","queuedText","group","charAt","lastIndex","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","start","Math","max","eol","firstLine","substring","clone","tokenType","compile","all","$all","ruleMap","included","newRules","k","newRule","apply","fastKeys","freeze","keywords","reverseMap","byLength","types","item","keyword","str","x","Function","module","exports","moo","singleSpace","toLowerCase","number","findToken","tokens","startingIndex","predicate","level","queryTokens","targetParenLevel","findParenLevelToken","findLimitInsertionIndex","nextNonCommentNonWhitespace","require$$0","fetchKeywordToken","nextNonWC","statementKeywordIndex","limit","insertBeforeToken","fetchToOnlyTokens","createToken","firstHalf","secondhalf","terminatorToken","targetIndex","firstKeywordToken","limitNumber","limitKeywordToken","firstNumber","possibleComma","secondNumber","fetch","first","top","topKeywordToken","parenLevel","statementToken","fetchToken","limitToken","strategiesToEnforce","strategies","toEnforce","numberToken","parseInt","preferredStrategy","stripTerminator","whitespace","comment","lparen","rparen","comma","period","terminator","quotedIdentifier","string","identifier","defs","defineKeywords","caseInsensitiveKeywords","operator","sqlText","statements","statement","Statement","appendToken","limitStrategies","getStatements","enforceLimit","removeTerminator","sqlStatement","trim","diff","Timeout","timeout","EditCost","editCost","DIFF_DELETE","main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","checklines","commonlength","commonPrefix","commonprefix","commonSuffix","commonsuffix","diffs","compute_","unshift","cleanupMerge","longtext","shorttext","hm","halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","lineMode_","bisect_","linesToChars_","chars1","chars2","linearray","lineArray","charsToLines_","cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","delta","front","k1start","k1end","k2start","k2end","k1","k1_offset","y1","x1","k2_offset","x2","bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","String","fromCharCode","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","xIndex","loc","last_chars1","last_chars2","prettyHtml","pattern_amp","pattern_lt","pattern_gt","pattern_br","op","levenshtein","insertions","deletions","toDelta","encodeURI","fromDelta","diffsLength","split","param","decodeURI","ex","isNaN","textDiff","sql","Diff","limited","sqlLimiter","label","selected_option","querySelector","strategy1","strategy2","strategy3","original","body"],"mappings":"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,gBACA,QACA,SACA,QACA,eACA,eACA,oBACA,eACA,UACA,SACA,WACA,OACA,MACA,OACA,aACA,MACA,UACA,UACA,UACA,aACA,WACA,SACA,OACA,OACA,WACA,aACA,cACA,aACA,OACA,WACA,cACA,SACA,SACA,OACA,OACA,OACA,WACA,MACA,SACA,SACA,SACA,YACA,OACA,UACA,SACA,OACA,WACA,UACA,QACA,QACA,OACA,aACA,QACA,QACA,MACA,UACA,UACA,QACA,WACA,gBACA,OACA,OACA,WACA,MACA,SACA,KACA,OACA,QACA,QACA,SACA,WACA,OACA,kBACA,WACA,cACA,KACA,YACA,KACA,UACA,QACA,YACA,YACA,QACA,QACA,cACA,SACA,MACA,UACA,YACA,WACA,OACA,KACA,YACA,OACA,MACA,OACA,WACA,OACA,UACA,OACA,QACA,OACA,QACA,SACA,OACA,QACA,SACA,QACA,QACA,MACA,QACA,MACA,SACA,SACA,QACA,QACA,WACA,UACA,QACA,OACA,KACA,UACA,eACA,OACA,MACA,SACA,OACA,SACA,UACA,eACA,KACA,MACA,SACA,UACA,KACA,OACA,OACA,iBACA,YACA,aACA,UACA,SACA,KACA,QACA,QACA,SACA,OACA,WACA,MACA,UACA,SACA,UACA,QACA,OACA,WACA,YACA,UACA,WACA,UACA,QACA,QACA,aACA,OACA,YACA,SACA,YACA,OACA,WACA,OACA,cACA,aACA,WACA,cACA,UACA,WACA,SACA,SACA,SACA,QACA,QACA,WACA,MACA,WACA,aACA,OACA,OACA,OACA,SACA,SACA,SACA,UACA,gBACA,SACA,yBACA,iCACA,0BACA,eACA,UACA,MACA,UACA,QACA,WACA,OACA,OACA,WACA,OACA,QACA,MACA,QACA,UACA,WACA,WACA,aACA,aACA,YACA,MACA,cACA,QACA,cACA,YACA,WACA,OACA,OACA,YACA,gBACA,kBACA,KACA,MACA,WACA,OACA,cACA,YACA,cACA,UACA,OACA,OACA,WACA,cAC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"}
{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/text-diff/diff.js","../../../node_modules/moo/moo.js","../../../src/create-token.js","../../../src/token-utils.js","../../../src/strategies/fetch.js","../../../src/strategies/first.js","../../../src/strategies/limit.js","../../../src/strategies/top.js","../../../src/strategies/index.js","../../../src/statement.js","../../../src/get-statements.js","../../../src/keywords.js","../../../src/index.js","../../src/SqlDiff.svelte","../../src/Strategies.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value' || descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j];\n                if (attributes[attribute.name]) {\n                    j++;\n                }\n                else {\n                    node.removeAttribute(attribute.name);\n                }\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    let unsubscribe;\n    if (is_crossorigin()) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        detach(iframe);\n        if (unsubscribe)\n            unsubscribe();\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next, lookup.has(block.key));\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.2' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","/**\n * This library was modified by Harrison Liddiard. The source code to this\n * modified version can be found at https://github.com/liddiard/google-diff/.\n * The original source code can be found at\n * http://code.google.com/p/google-diff-match-patch/. This unofficial fork is\n * not maintained by or affiliated with Google Inc. The original attribution\n * and licensing information follows.\n */\n\n/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff.\n * @constructor\n */\nfunction diff(options) {\n  var options = options || {};\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Timeout = options.timeout || 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.EditCost = options.editCost || 4;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {{0: number, 1: string}} */\ndiff.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n */\ndiff.prototype.main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.lineMode_(text1, text2, deadline);\n  }\n\n  return this.bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var a = this.main(text_delete, text_insert, false, deadline);\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @private\n */\ndiff.prototype.bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.main(text1a, text2a, false, deadline);\n  var diffsb = this.main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff.prototype.linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff.prototype.charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff.prototype.commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff.prototype.commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff.prototype.commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff.prototype.halfMatch_ = function(text1, text2) {\n  if (this.Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.commonPrefix(longtext.substring(i),\n                                          shorttext.substring(j));\n      var suffixLength = dmp.commonSuffix(longtext.substring(0, i),\n                                          shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n  this.cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0,\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff.whitespaceRegex_ = /\\s/;\ndiff.linebreakRegex_ = /[\\r\\n]/;\ndiff.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n */\ndiff.prototype.cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff.prototype.xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff.prototype.prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_br = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_br, '<br/>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins>' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del>' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff.prototype.text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff.prototype.text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff.prototype.levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff.prototype.toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff.prototype.fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// Users of node.js should 'require' the uncompressed version since Google's\n// JS compiler may break the following exports for non-browser environments.\nthis['diff'] = diff;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\nmodule.exports = diff;\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    var start = Math.max(0, token.offset - token.col + 1)\n    var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length\n    var firstLine = this.buffer.substring(start, token.offset + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","module.exports = {\n  singleSpace() {\n    return {\n      type: \"whitespace\",\n      text: \" \",\n      value: \" \",\n    };\n  },\n  keyword(text) {\n    return {\n      type: \"keyword\",\n      text,\n      value: text.toLowerCase(),\n    };\n  },\n  number(n) {\n    return {\n      type: \"number\",\n      text: `${n}`,\n      value: n,\n    };\n  },\n};\n","function findParenLevelToken(tokens, startingIndex, predicate) {\n  let level = 0;\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (!token) {\n      return null;\n    }\n    if (token.type === \"lparen\") {\n      level++;\n    } else if (token.type === \"rparen\") {\n      level--;\n    } else if (level === 0 && predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction findToken(tokens, startingIndex, predicate) {\n  for (let i = startingIndex; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (predicate(token)) {\n      return { ...token, index: i };\n    }\n  }\n  return null;\n}\n\nfunction nextNonCommentNonWhitespace(tokens, startingIndex) {\n  return findToken(\n    tokens,\n    startingIndex,\n    (token) => token.type !== \"whitespace\" && token.type !== \"comment\"\n  );\n}\n\nfunction findLimitInsertionIndex(queryTokens, targetParenLevel) {\n  let level = 0;\n  for (let i = queryTokens.length - 1; i >= 0; i--) {\n    const token = queryTokens[i];\n    if (\n      level === targetParenLevel &&\n      token.type !== \"comment\" &&\n      token.type !== \"whitespace\"\n    ) {\n      return i + 1;\n    }\n\n    if (token.type === \"rparen\") {\n      level++;\n    } else if (token.type === \"lparen\") {\n      level--;\n    }\n  }\n  // This should never happen.\n  // And if it did this lib doesn't know what to do\n  throw new Error(\"Unexpected index\");\n}\n\nmodule.exports = {\n  findParenLevelToken,\n  findToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Determines whether query tokens have \"FETCH\" style limits\n * Postgres, IBM, Actian/Ingres, SQL Server 2012 support this SQL 2008 addition\n *\n * The postgres docs showcase the format nicely:\n * [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]\n * [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]\n *\n * For the purposes of sql-limiter, we will look for \"fetch first <number>\" and \"fetch next <number>\"\n * Assuming that whitespace or comments can be between\n *\n * Resources:\n * https://www.postgresql.org/docs/12/sql-select.html\n * https://docs.actian.com/ingres/10s/index.html#page/SQLRef%2FSELECT_Clause.htm%23\n * https://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/sqlref/src/tpc/db2z_sql_fetchfirstclause.html\n * https://use-the-index-luke.com/sql/partial-results/top-n-queries\n *\n * @param {array<object>} tokens\n * @param {number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const fetchKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"fetch\"\n  );\n\n  if (!fetchKeywordToken) {\n    return null;\n  }\n\n  let nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    fetchKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (\n    nextNonWC.type !== \"keyword\" ||\n    (nextNonWC.value !== \"next\" && nextNonWC.value !== \"first\")\n  ) {\n    throw new Error(`Unexpected token: ${nextNonWC.type} ${nextNonWC.value}`);\n  }\n\n  nextNonWC = nextNonCommentNonWhitespace(tokens, nextNonWC.index + 1);\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // fetch first was not found, so figure out where it should be inserted\n  // fetch first goes at end before for if that exists. Otherwise before terminator if it exists\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"keyword\" && token.value === \"for\"\n  );\n\n  const fetchToOnlyTokens = [\n    createToken.keyword(\"fetch\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    createToken.singleSpace(),\n    createToken.keyword(\"rows\"),\n    createToken.singleSpace(),\n    createToken.keyword(\"only\"),\n  ];\n\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      ...fetchToOnlyTokens,\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      ...fetchToOnlyTokens,\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    ...fetchToOnlyTokens,\n    ...secondhalf,\n  ];\n}\n\nmodule.exports = {\n  has,\n  add,\n};\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the FIRST keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const firstKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"first\"\n  );\n\n  if (!firstKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    firstKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds FIRST to query that does not have it.\n *\n * FIRST is an Actian keyword that operates similar to SQL Server's TOP.\n * TODO - find documentation/examples to figure out if there are any potential edge cases with this solution\n * https://docs.actian.com/vectorhadoop/6.0/#page/SQLLang%2FSELECT_(Interactive).htm%23\n *\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // FIRST was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"first\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  findLimitInsertionIndex,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\nfunction has(tokens, startingIndex) {\n  const limitKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"limit\"\n  );\n\n  if (!limitKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    limitKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds limit to query that does not have it\n * @param {*} queryTokens\n * @param {*} statementKeywordIndex\n * @param {*} targetParenLevel\n * @param {*} limit\n */\nfunction add(queryTokens, statementKeywordIndex, targetParenLevel, limit) {\n  // Limit was not found, so figure out where it should be inserted\n  // If last keyword is offset, need to put limit before that\n  // If not offset, put limit at end, before terminator if present\n  const insertBeforeToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) =>\n      token.type === \"keyword\" &&\n      (token.value === \"offset\" || token.value === \"for\")\n  );\n  if (insertBeforeToken) {\n    const firstHalf = queryTokens.slice(0, insertBeforeToken.index);\n    const secondhalf = queryTokens.slice(insertBeforeToken.index);\n    return [\n      ...firstHalf,\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      createToken.singleSpace(),\n      ...secondhalf,\n    ];\n  }\n\n  // If there is a terminator add it just before\n  const terminatorToken = findParenLevelToken(\n    queryTokens,\n    statementKeywordIndex,\n    (token) => token.type === \"terminator\"\n  );\n  if (terminatorToken) {\n    const firstHalf = queryTokens.slice(0, terminatorToken.index);\n    const secondhalf = queryTokens.slice(terminatorToken.index);\n    return [\n      ...firstHalf,\n      createToken.singleSpace(),\n      createToken.keyword(\"limit\"),\n      createToken.singleSpace(),\n      createToken.number(limit),\n      ...secondhalf,\n    ];\n  }\n\n  // No terminator. Append to end\n  // skipping past any trailing comments, whitespace, terminator\n  const targetIndex = findLimitInsertionIndex(queryTokens, targetParenLevel);\n  const firstHalf = queryTokens.slice(0, targetIndex);\n  const secondhalf = queryTokens.slice(targetIndex);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"limit\"),\n    createToken.singleSpace(),\n    createToken.number(limit),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const createToken = require(\"../create-token\");\nconst {\n  findParenLevelToken,\n  nextNonCommentNonWhitespace,\n} = require(\"../token-utils\");\n\n/**\n * Find token containing the number following the TOP keyword\n * @param {Array<Object>} tokens\n * @param {Number} startingIndex\n */\nfunction has(tokens, startingIndex) {\n  const topKeywordToken = findParenLevelToken(\n    tokens,\n    startingIndex,\n    (token) => token.type === \"keyword\" && token.value === \"top\"\n  );\n\n  if (!topKeywordToken) {\n    return null;\n  }\n\n  const nextNonWC = nextNonCommentNonWhitespace(\n    tokens,\n    topKeywordToken.index + 1\n  );\n\n  if (!nextNonWC) {\n    throw new Error(\"Unexpected end of statement\");\n  }\n\n  if (nextNonWC.type !== \"number\") {\n    throw new Error(`Expected number got ${nextNonWC.type}`);\n  }\n\n  return nextNonWC;\n}\n\n/**\n * Adds TOP to query that does not have it.\n *\n * TOP in Actian behaves similar to its FIRST keyword, and SQL Server's TOP (though unclear about its compat with UNION)\n * @param {Array<Object>} tokens\n * @param {Number} statementKeywordIndex\n * @param {Number} targetParenLevel\n * @param {Number} limitNumber\n */\nfunction add(tokens, statementKeywordIndex, targetParenLevel, limitNumber) {\n  // TOP was not found, so put it immediately following the SELECT statement\n  const firstHalf = tokens.slice(0, statementKeywordIndex + 1);\n  const secondhalf = tokens.slice(statementKeywordIndex + 1);\n  return [\n    ...firstHalf,\n    createToken.singleSpace(),\n    createToken.keyword(\"top\"),\n    createToken.singleSpace(),\n    createToken.number(limitNumber),\n    ...secondhalf,\n  ];\n}\n\nexports.has = has;\nexports.add = add;\n","const fetch = require(\"./fetch\");\nconst first = require(\"./first\");\nconst limit = require(\"./limit\");\nconst top = require(\"./top\");\n\nmodule.exports = {\n  fetch,\n  first,\n  limit,\n  top,\n};\n","/* eslint-disable no-restricted-syntax */\nconst strategies = require(\"./strategies\");\n\nclass Statement {\n  constructor() {\n    this.tokens = [];\n    this.parenLevel = 0;\n    this.targetParenLevel = null;\n    this.statementToken = null;\n    this.fetchToken = null;\n    this.limitToken = null;\n  }\n\n  appendToken(t) {\n    const token = { ...t };\n    token.parenLevel = this.parenLevel;\n    // Index once token is added\n    token.index = this.tokens.length;\n    this.tokens.push(token);\n\n    if (token.type === \"lparen\") {\n      this.parenLevel++;\n    } else if (token.type === \"rparen\") {\n      this.parenLevel--;\n    } else if (token.type === \"keyword\") {\n      // If targetParenLevel has not yet been set,\n      // we are dealing with the first keyword, which informs us of the \"level\"\n      // we want to consider for finding SELECT statments\n      if (this.targetParenLevel === null) {\n        this.targetParenLevel = this.parenLevel;\n      }\n      // Statement keyword we are considering not something found in prep of CTE\n      // If the current keyword isn't a `with` and not `as`, and at the same level as our targetParenLevel,\n      // We can assume it tells us what kind of query we are dealing with.\n      // Consider queries like the following queries\n      //\n      // WITH cte AS (...) SELECT ...\n      // WITH cte AS (...) INSERT INTO ... SELECT\n      // WITH cte AS (...) UPDATE ... FROM ...\n      // (WITH cte AS (...) SELECT ...)\n      if (\n        !this.statementToken &&\n        this.targetParenLevel === this.parenLevel &&\n        token.value !== \"with\" &&\n        token.value !== \"as\"\n      ) {\n        this.statementToken = token;\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Array<String>} strategiesToEnforce\n   * @param {Number} limitNumber\n   */\n  enforceLimit(strategiesToEnforce, limitNumber) {\n    const { statementToken, tokens } = this;\n\n    strategiesToEnforce.forEach((s) => {\n      if (!strategies[s]) {\n        throw new Error(`Strategy ${s} not supported`);\n      }\n    });\n\n    if (statementToken && statementToken.value === \"select\") {\n      for (const toEnforce of strategiesToEnforce) {\n        const strategyImplementation = strategies[toEnforce];\n        const numberToken = strategyImplementation.has(\n          tokens,\n          statementToken.index\n        );\n\n        // If number token, check to see if over the limit and reset it if it is\n        // Otherwise return early\n        if (numberToken) {\n          if (parseInt(numberToken.value, 10) > limitNumber) {\n            const firstHalf = tokens.slice(0, numberToken.index);\n            const secondhalf = tokens.slice(numberToken.index + 1);\n            this.tokens = [\n              ...firstHalf,\n              { ...numberToken, text: limitNumber, value: limitNumber },\n              ...secondhalf,\n            ];\n            return;\n          }\n          return;\n        }\n      }\n\n      // An existing limit strategy was not found,\n      // so take the first one in list of strategies to enforce and add it to tokens\n      const preferredStrategy = strategiesToEnforce[0];\n      this.tokens = strategies[preferredStrategy].add(\n        tokens,\n        statementToken.index,\n        statementToken.parenLevel,\n        limitNumber\n      );\n    }\n  }\n\n  toString(stripTerminator = false) {\n    if (stripTerminator) {\n      return this.tokens\n        .filter((t) => t.type !== \"terminator\")\n        .map((t) => t.text)\n        .join(\"\");\n    }\n    return this.tokens.map((token) => token.text).join(\"\");\n  }\n}\n\nmodule.exports = Statement;\n","const moo = require(\"moo\");\nconst keywords = require(\"./keywords.js\");\nconst Statement = require(\"./statement\");\n\n// Incoming values will also be compared as lower case to make keyword matching case insensitive\nconst caseInsensitiveKeywords = (defs) => {\n  const defineKeywords = moo.keywords(defs);\n  return (value) => defineKeywords(value.toLowerCase());\n};\n\nconst lexer = moo.compile({\n  whitespace: [\n    /[ \\t]+/u,\n    { match: /\\r\\n/u, lineBreaks: true },\n    { match: /\\n/u, lineBreaks: true },\n  ],\n  // First expression is --line comment, second is /* multi line */\n  comment: [/--.*?$/u, /\\/\\*[^]*?\\*\\//u],\n  lparen: \"(\",\n  rparen: \")\",\n  comma: \",\",\n  period: \".\",\n\n  number: /0|[1-9][0-9]*/u,\n\n  // ; is standard, \\g is a shortcut used in psql and Actian tooling\n  // Are there others?\n  terminator: [\";\", \"\\\\g\"],\n\n  // text == original text\n  // value == value inside quotes\n  quotedIdentifier: [\n    {\n      match: /\".*?\"/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /\\[.*?\\]/u,\n      value: (x) => x.slice(1, -1),\n    },\n    {\n      match: /`.*?`/u,\n      value: (x) => x.slice(1, -1),\n    },\n  ],\n\n  // Updated to allow multi-line strings,\n  // which is allowed by some database drivers (sqlite, actian)\n  // This does not correctly handle escaped doublequotes, however the end result is ok for sql-limiter\n  // Instead of a single string token we get 2 separate string tokens back-to-back\n  string: [\n    {\n      match: /'[^']*'/u,\n      lineBreaks: true,\n    },\n  ],\n\n  // Remaining test is assumed to be an identifier of some kinds (column or table)\n  // UNLESS it matches a keyword case insensitively\n  // The value of these tokens are converted to lower case\n  identifier: [\n    {\n      // This is added to handle non-english identifiers.\n      // This range may be too broad\n      // eslint-disable-next-line no-control-regex\n      match: /(?:\\w|[^\\u0000-\\u007F])+/u,\n      type: caseInsensitiveKeywords({\n        keyword: keywords,\n      }),\n      value: (s) => s.toLowerCase(),\n    },\n  ],\n\n  // Any combination of special characters is to be treated as an operator (as a guess anyways)\n  // Initially these were being noted here but the list is large\n  // and there is no way to know all operators since this supports anything that is SQL-ish\n  operator: {\n    match: /[<>~!@#$%^?&|`*\\-{}+=:/\\\\[\\]]+/u,\n    lineBreaks: false,\n  },\n});\n\n/**\n * Takes SQL text and generates an array of tokens using moo\n * @param {string} sqlText\n */\nfunction getStatements(sqlText) {\n  const statements = [];\n  let statement = new Statement();\n\n  lexer.reset(sqlText);\n  let next = lexer.next();\n\n  while (next) {\n    statement.appendToken(next);\n    if (next.type === \"terminator\") {\n      statements.push(statement);\n      statement = new Statement();\n    }\n    next = lexer.next();\n  }\n  // push last set\n  if (statement.tokens.length) {\n    statements.push(statement);\n  }\n  return statements;\n}\n\nmodule.exports = getStatements;\n","module.exports = [\n  \"absolute\",\n  \"action\",\n  \"ada\",\n  \"add\",\n  \"all\",\n  \"allocate\",\n  \"alter\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"as\",\n  \"asc\",\n  \"assertion\",\n  \"at\",\n  \"authorization\",\n  \"avg\",\n  \"backup\",\n  \"begin\",\n  \"between\",\n  \"bit_length\",\n  \"bit\",\n  \"both\",\n  \"break\",\n  \"browse\",\n  \"bulk\",\n  \"by\",\n  \"cascade\",\n  \"cascaded\",\n  \"case\",\n  \"cast\",\n  \"catalog\",\n  \"char_length\",\n  \"char\",\n  \"character_length\",\n  \"character\",\n  \"check\",\n  \"checkpoint\",\n  \"close\",\n  \"clustered\",\n  \"coalesce\",\n  \"collate\",\n  \"collation\",\n  \"column\",\n  \"commit\",\n  \"compute\",\n  \"connect\",\n  \"connection\",\n  \"constraint\",\n  \"constraints\",\n  \"contains\",\n  \"containstable\",\n  \"continue\",\n  \"convert\",\n  \"corresponding\",\n  \"count\",\n  \"create\",\n  \"cross\",\n  \"current_date\",\n  \"current_time\",\n  \"current_timestamp\",\n  \"current_user\",\n  \"current\",\n  \"cursor\",\n  \"database\",\n  \"date\",\n  \"day\",\n  \"dbcc\",\n  \"deallocate\",\n  \"dec\",\n  \"decimal\",\n  \"declare\",\n  \"default\",\n  \"deferrable\",\n  \"deferred\",\n  \"delete\",\n  \"deny\",\n  \"desc\",\n  \"describe\",\n  \"descriptor\",\n  \"diagnostics\",\n  \"disconnect\",\n  \"disk\",\n  \"distinct\",\n  \"distributed\",\n  \"domain\",\n  \"double\",\n  \"drop\",\n  \"dump\",\n  \"else\",\n  \"end-exec\",\n  \"end\",\n  \"errlvl\",\n  \"escape\",\n  \"except\",\n  \"exception\",\n  \"exec\",\n  \"execute\",\n  \"exists\",\n  \"exit\",\n  \"external\",\n  \"extract\",\n  \"false\",\n  \"fetch\",\n  \"file\",\n  \"fillfactor\",\n  \"first\",\n  \"float\",\n  \"for\",\n  \"foreign\",\n  \"fortran\",\n  \"found\",\n  \"freetext\",\n  \"freetexttable\",\n  \"from\",\n  \"full\",\n  \"function\",\n  \"get\",\n  \"global\",\n  \"go\",\n  \"goto\",\n  \"grant\",\n  \"group\",\n  \"having\",\n  \"holdlock\",\n  \"hour\",\n  \"identity_insert\",\n  \"identity\",\n  \"identitycol\",\n  \"if\",\n  \"immediate\",\n  \"in\",\n  \"include\",\n  \"index\",\n  \"indicator\",\n  \"initially\",\n  \"inner\",\n  \"input\",\n  \"insensitive\",\n  \"insert\",\n  \"int\",\n  \"integer\",\n  \"intersect\",\n  \"interval\",\n  \"into\",\n  \"is\",\n  \"isolation\",\n  \"join\",\n  \"key\",\n  \"kill\",\n  \"language\",\n  \"last\",\n  \"leading\",\n  \"left\",\n  \"level\",\n  \"like\",\n  \"limit\",\n  \"lineno\",\n  \"load\",\n  \"local\",\n  \"locked\",\n  \"lower\",\n  \"match\",\n  \"max\",\n  \"merge\",\n  \"min\",\n  \"minute\",\n  \"module\",\n  \"month\",\n  \"names\",\n  \"national\",\n  \"natural\",\n  \"nchar\",\n  \"next\",\n  \"no\",\n  \"nocheck\",\n  \"nonclustered\",\n  \"none\",\n  \"not\",\n  \"nowait\",\n  \"null\",\n  \"nullif\",\n  \"numeric\",\n  \"octet_length\",\n  \"of\",\n  \"off\",\n  \"offset\",\n  \"offsets\",\n  \"on\",\n  \"only\",\n  \"open\",\n  \"opendatasource\",\n  \"openquery\",\n  \"openrowset\",\n  \"openxml\",\n  \"option\",\n  \"or\",\n  \"order\",\n  \"outer\",\n  \"output\",\n  \"over\",\n  \"overlaps\",\n  \"pad\",\n  \"partial\",\n  \"pascal\",\n  \"percent\",\n  \"pivot\",\n  \"plan\",\n  \"position\",\n  \"precision\",\n  \"prepare\",\n  \"preserve\",\n  \"primary\",\n  \"print\",\n  \"prior\",\n  \"privileges\",\n  \"proc\",\n  \"procedure\",\n  \"public\",\n  \"raiserror\",\n  \"read\",\n  \"readtext\",\n  \"real\",\n  \"reconfigure\",\n  \"references\",\n  \"relative\",\n  \"replication\",\n  \"restore\",\n  \"restrict\",\n  \"return\",\n  \"revert\",\n  \"revoke\",\n  \"right\",\n  \"right\",\n  \"rollback\",\n  \"row\",\n  \"rowcount\",\n  \"rowguidcol\",\n  \"rows\",\n  \"rule\",\n  \"save\",\n  \"schema\",\n  \"scroll\",\n  \"second\",\n  \"section\",\n  \"securityaudit\",\n  \"select\",\n  \"semantickeyphrasetable\",\n  \"semanticsimilaritydetailstable\",\n  \"semanticsimilaritytable\",\n  \"session_user\",\n  \"session\",\n  \"set\",\n  \"setuser\",\n  \"share\",\n  \"shutdown\",\n  \"size\",\n  \"skip\",\n  \"smallint\",\n  \"some\",\n  \"space\",\n  \"sql\",\n  \"sqlca\",\n  \"sqlcode\",\n  \"sqlerror\",\n  \"sqlstate\",\n  \"sqlwarning\",\n  \"statistics\",\n  \"substring\",\n  \"sum\",\n  \"system_user\",\n  \"table\",\n  \"tablesample\",\n  \"temporary\",\n  \"textsize\",\n  \"then\",\n  \"time\",\n  \"timestamp\",\n  \"timezone_hour\",\n  \"timezone_minute\",\n  \"to\",\n  \"top\",\n  \"trailing\",\n  \"tran\",\n  \"transaction\",\n  \"translate\",\n  \"translation\",\n  \"trigger\",\n  \"trim\",\n  \"true\",\n  \"truncate\",\n  \"try_convert\",\n  \"tsequal\",\n  \"union\",\n  \"unique\",\n  \"unknown\",\n  \"unpivot\",\n  \"update\",\n  \"updatetext\",\n  \"upper\",\n  \"usage\",\n  \"use\",\n  \"user\",\n  \"using\",\n  \"value\",\n  \"values\",\n  \"varchar\",\n  \"varying\",\n  \"view\",\n  \"waitfor\",\n  \"when\",\n  \"whenever\",\n  \"where\",\n  \"while\",\n  \"with\",\n  \"within group\",\n  \"work\",\n  \"write\",\n  \"writetext\",\n  \"year\",\n  \"zone\",\n];\n","const getStatements = require(\"./get-statements\");\n\n/**\n * Enforce limit/top on SQL SELECT queries.\n * Non SELECT queries will not be altered.\n * If existing limit exists, it will be lowered if it is larger than `limitNumber` specified\n * If limit does not exist, it will be added.\n * Returns SQL text with limits enforced.\n *\n * @param {string} sqlText - sql text to limit\n * @param {Array<String>|String} limitStrategies -- Values must be `limit` and/or `fetch`. First value takes priority if no limit exists\n * @param {number} limitNumber -- number to enforce for limit keyword\n * @returns {string}\n */\nfunction limit(sqlText, limitStrategies, limitNumber) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  if (typeof limitNumber !== \"number\") {\n    throw new Error(\"limitNumber must be number\");\n  }\n\n  let strategies =\n    typeof limitStrategies === \"string\" ? [limitStrategies] : limitStrategies;\n\n  if (!Array.isArray(strategies)) {\n    throw new Error(\"limitStrategies must be an array or string\");\n  }\n\n  if (strategies.length === 0) {\n    throw new Error(\"limitStrategies must not be empty\");\n  }\n\n  strategies = strategies.map((s) => s.toLowerCase());\n\n  return getStatements(sqlText)\n    .map((statement) => {\n      statement.enforceLimit(strategies, limitNumber);\n      return statement.toString();\n    })\n    .join(\"\");\n}\n\n/**\n * Splits SQL text on terminator, returning an array of SQL statements\n * @param {string} sqlText\n */\nfunction apiGetStatements(sqlText) {\n  if (typeof sqlText !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlText);\n  return statements.map((statement) => statement.toString());\n}\n\n/**\n * Removes terminator from SQL statement.\n * Only a single statement allowed.\n * Throws error if multiple statements are included\n * @param {string} sqlStatement\n */\nfunction removeTerminator(sqlStatement) {\n  if (typeof sqlStatement !== \"string\") {\n    throw new Error(\"sqlText must be string\");\n  }\n  const statements = getStatements(sqlStatement)\n    .map((s) => s.toString(true))\n    .filter((s) => s.trim() !== \"\");\n\n  if (statements.length > 1) {\n    throw new Error(\"Multiple statements detected\");\n  }\n\n  return statements[0];\n}\n\nmodule.exports = {\n  limit,\n  getStatements: apiGetStatements,\n  removeTerminator,\n};\n","<script>\n  import sqlLimiter from \"../../src/index.js\";\n  import Diff from \"text-diff\";\n  import Logo from \"./Logo.svelte\";\n\n  export let sql = \"\";\n  export let strategies = [\"limit\"];\n  export let limitNumber = 100;\n\n  let diff = new Diff();\n  let limited = \"\";\n  let textDiff;\n  let prettyHtml;\n  let error;\n\n  $: try {\n    error = null;\n    limited = sqlLimiter.limit(sql, strategies, limitNumber);\n    textDiff = diff.main(sql, limited);\n    prettyHtml = diff.prettyHtml(textDiff);\n  } catch (e) {\n    error = e;\n  }\n</script>\n\n<style>\n  :global(ins) {\n    color: green;\n  }\n\n  :global(del) {\n    color: red;\n  }\n\n  .error {\n    color: red;\n  }\n</style>\n\n{#if error}\n  <span class=\"error\">{error}</span>\n{:else}\n  {@html prettyHtml}\n{/if}\n","<script>\n  export let value = \"\";\n  export let label = \"strategy\";\n</script>\n\n<style>\n  label {\n    font-variant: small-caps;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n</style>\n\n<label for={label}>{label}</label>\n<select id={label} class=\"input\" bind:value>\n  <option value=\"\">\n    <em>none</em>\n  </option>\n  <option value=\"fetch\">fetch</option>\n  <option value=\"first\">first</option>\n  <option value=\"limit\">limit</option>\n  <option value=\"top\">top</option>\n</select>\n","<script>\n  import Diff from \"text-diff\";\n  import Logo from \"./Logo.svelte\";\n  import SqlDiff from \"./SqlDiff.svelte\";\n  import Strategies from \"./Strategies.svelte\";\n\n  let strategy1 = \"limit\";\n  let strategy2 = \"fetch\";\n  let strategy3 = \"\";\n  let limitNumber = 100;\n  let original = `SELECT * FROM some_table;`;\n\n  $: limitStrategies = [strategy1, strategy2, strategy3].filter(s => s !== \"\");\n</script>\n\n<style>\n  h1 {\n    color: #ff3e00;\n    font-variant: small-caps;\n    text-transform: uppercase;\n    font-size: 2em;\n    font-weight: 100;\n  }\n\n  label {\n    font-variant: small-caps;\n  }\n\n  .row {\n    display: flex;\n  }\n\n  .m8 {\n    margin: 8px;\n  }\n\n  .col-100 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n  .col-50 {\n    box-sizing: border-box;\n    width: 50%;\n    flex-grow: 1;\n  }\n\n  #sql-in {\n    white-space: pre;\n  }\n\n  /* consistent styling for textarea and not */\n  .sql {\n    border-radius: 2px;\n    border: 1px solid #ccc;\n    box-sizing: border-box;\n    font-family: monospace;\n    font-size: 14px;\n    margin: 0;\n    padding: 8px;\n    width: 100%;\n  }\n\n  .input {\n    width: 180px;\n    height: 36px;\n  }\n\n  .out {\n    overflow-x: auto;\n  }\n</style>\n\n<main>\n  <Logo />\n  <div class=\"row\">\n    <div class=\"col-100 m8\">\n      <h1>sql-limiter</h1>\n\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"m8\">\n      <Strategies label=\"strategy 1\" bind:value={strategy1} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 2\" bind:value={strategy2} />\n    </div>\n    <div class=\"m8\">\n      <Strategies label=\"strategy 3\" bind:value={strategy3} />\n    </div>\n    <div class=\"m8\">\n      <label for=\"limit-number\">limit number</label>\n      <input\n        id=\"limit-number\"\n        class=\"input\"\n        type=\"number\"\n        bind:value={limitNumber} />\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"col-50 m8\">\n      <label for=\"sql-in\">input</label>\n      <textarea id=\"sql-in\" class=\"sql\" rows=\"15\" bind:value={original} />\n    </div>\n    <div class=\"col-50 m8\">\n      <label>result</label>\n      <pre class=\"sql out\">\n        <SqlDiff sql={original} strategies={limitStrategies} {limitNumber} />\n      </pre>\n    </div>\n  </div>\n\n</main>\n","import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","to_number","undefined","set_data","set_input_value","input","select_option","select","i","length","option","__value","selected","HtmlTag","[object Object]","html","this","e","u","n","t","innerHTML","Array","from","childNodes","d","m","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","add_flush_callback","flushing","seen_callbacks","Set","flush","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","transition_out","o","outros","c","bind","index","props","bound","create_component","mount_component","on_mount","on_destroy","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","parent_component","prop_values","context","Map","callbacks","ready","ret","rest","hydrate","nodes","children","l","intro","SvelteComponent","$destroy","type","indexOf","splice","diff","Timeout","timeout","EditCost","editCost","prototype","main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","commonPrefix","commonprefix","substring","commonSuffix","commonsuffix","diffs","compute_","unshift","cleanupMerge","longtext","shorttext","hm","halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","lineMode_","bisect_","linesToChars_","chars1","chars2","linearray","lineArray","charsToLines_","cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","j","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","v2","x","delta","front","k1start","k1end","k2start","k2end","k1","k1_offset","y1","x1","charAt","k2_offset","x2","bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","String","fromCharCode","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","xIndex","loc","last_chars1","last_chars2","prettyHtml","pattern_amp","pattern_lt","pattern_gt","pattern_br","op","replace","levenshtein","insertions","deletions","toDelta","encodeURI","fromDelta","diffsLength","tokens","split","param","decodeURI","ex","parseInt","isNaN","root","factory","toString","hasSticky","RegExp","sticky","isRegExp","call","isObject","isArray","reCapture","s","reUnion","regexps","regexpOrLiteral","obj","ignoreCase","global","multiline","source","ruleOptions","include","defaultType","lineBreaks","error","fallback","next","shouldThrow","key","sort","toRules","spec","array","result","JSON","stringify","arrayToRules","object","keys","getOwnPropertyNames","rules","rule","objectToRules","defaultErrorRule","compileRules","hasStates","errorRule","fast","fastAllowed","unicodeFlag","groups","parts","slice","shift","unicode","pat","regexp","test","exec","fallbackRule","flags","suffix","checkStateGroup","g","state","Lexer","states","startState","buffer","stack","reset","info","col","queuedToken","queuedThrow","setState","save","re","popState","pushState","eat","tokenToString","_getGroup","groupCount","queuedGroup","token","_token","queuedText","group","lastIndex","offset","matchNL","nl","size","formatError","Symbol","iterator","LexerIterator","lexer","done","message","start","eol","firstLine","clone","tokenType","compile","all","$all","ruleMap","included","newRules","k","newRule","apply","fastKeys","freeze","keywords","reverseMap","byLength","types","item","keyword","str","Function","module","exports","moo","singleSpace","toLowerCase","number","findToken","startingIndex","predicate","findParenLevelToken","level","findLimitInsertionIndex","queryTokens","targetParenLevel","nextNonCommentNonWhitespace","require$$0","fetchKeywordToken","nextNonWC","statementKeywordIndex","limit","insertBeforeToken","fetchToOnlyTokens","createToken","firstHalf","secondhalf","terminatorToken","targetIndex","firstKeywordToken","limitNumber","limitKeywordToken","fetch","first","top","topKeywordToken","parenLevel","statementToken","fetchToken","limitToken","strategiesToEnforce","strategies","toEnforce","numberToken","preferredStrategy","stripTerminator","whitespace","comment","lparen","rparen","comma","period","terminator","quotedIdentifier","string","identifier","defs","defineKeywords","caseInsensitiveKeywords","operator","sqlText","statements","statement","Statement","appendToken","limitStrategies","getStatements","enforceLimit","removeTerminator","sqlStatement","trim","textDiff","sql","Diff","limited","sqlLimiter","label","selected_option","querySelector","strategy1","strategy2","strategy3","original","body"],"mappings":"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A,aACA,aACA,cACA,WACA,gBACA,WACA,UACA,gBACA,QACA,SACA,QACA,eACA,eACA,oBACA,eACA,UACA,SACA,WACA,OACA,MACA,OACA,aACA,MACA,UACA,UACA,UACA,aACA,WACA,SACA,OACA,OACA,WACA,aACA,cACA,aACA,OACA,WACA,cACA,SACA,SACA,OACA,OACA,OACA,WACA,MACA,SACA,SACA,SACA,YACA,OACA,UACA,SACA,OACA,WACA,UACA,QACA,QACA,OACA,aACA,QACA,QACA,MACA,UACA,UACA,QACA,WACA,gBACA,OACA,OACA,WACA,MACA,SACA,KACA,OACA,QACA,QACA,SACA,WACA,OACA,kBACA,WACA,cACA,KACA,YACA,KACA,UACA,QACA,YACA,YACA,QACA,QACA,cACA,SACA,MACA,UACA,YACA,WACA,OACA,KACA,YACA,OACA,MACA,OACA,WACA,OACA,UACA,OACA,QACA,OACA,QACA,SACA,OACA,QACA,SACA,QACA,QACA,MACA,QACA,MACA,SACA,SACA,QACA,QACA,WACA,UACA,QACA,OACA,KACA,UACA,eACA,OACA,MACA,SACA,OACA,SACA,UACA,eACA,KACA,MACA,SACA,UACA,KACA,OACA,OACA,iBACA,YACA,aACA,UACA,SACA,KACA,QACA,QACA,SACA,OACA,WACA,MACA,UACA,SACA,UACA,QACA,OACA,WACA,YACA,UACA,WACA,UACA,QACA,QACA,aACA,OACA,YACA,SACA,YACA,OACA,WACA,OACA,cACA,aACA,WACA,cACA,UACA,WACA,SACA,SACA,SACA,QACA,QACA,WACA,MACA,WACA,aACA,OACA,OACA,OACA,SACA,SACA,SACA,UACA,gBACA,SACA,yBACA,iCACA,0BACA,eACA,UACA,MACA,UACA,QACA,WACA,OACA,OACA,WACA,OACA,QACA,MACA,QACA,UACA,WACA,WACA,aACA,aACA,YACA,MACA,cACA,QACA,cACA,YACA,WACA,OACA,OACA,YACA,gBACA,kBACA,KACA,MACA,WACA,OACA,c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"}